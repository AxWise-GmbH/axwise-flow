<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Research Context Extraction</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .session {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            background: #f9f9f9;
        }
        .session h3 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .context-info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 5px 0;
        }
        .empty-field {
            color: #dc3545;
            font-weight: bold;
        }
        .filled-field {
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Research Context Extraction Test</h1>
        <p>This tool tests the improved context extraction logic for research sessions.</p>
        
        <div>
            <button onclick="showCurrentSessions()">Show Current Sessions</button>
            <button onclick="runCleanup()">Run Cleanup</button>
            <button onclick="forceCleanupAll()">Force Cleanup All Sessions</button>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <div class="container">
        <h2>Sessions Status</h2>
        <div id="sessions-container"></div>
    </div>

    <div class="container">
        <h2>Console Log</h2>
        <div id="log" class="log"></div>
    </div>

    <script>
        // Import the research API functions
        const STORAGE_KEYS = {
            sessions: 'axwise_research_sessions',
            currentSession: 'axwise_current_research_session',
            userId: 'axwise_anonymous_user_id'
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : type === 'warning' ? '⚠️' : 'ℹ️';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`${prefix} ${message}`);
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        function getSessions() {
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.sessions);
                if (!stored) return [];
                
                const sessions = JSON.parse(stored);
                return Array.isArray(sessions) ? sessions : Object.values(sessions);
            } catch (error) {
                log(`Error reading sessions: ${error.message}`, 'error');
                return [];
            }
        }

        function showCurrentSessions() {
            const sessions = getSessions();
            const container = document.getElementById('sessions-container');
            
            if (sessions.length === 0) {
                container.innerHTML = '<p>No sessions found in localStorage.</p>';
                log('No sessions found');
                return;
            }

            log(`Found ${sessions.length} sessions`);
            
            let html = '';
            sessions.forEach((session, index) => {
                const hasBusinessIdea = session.business_idea && session.business_idea.trim();
                const hasTargetCustomer = session.target_customer && session.target_customer.trim();
                const hasProblem = session.problem && session.problem.trim();
                const hasMessages = session.messages && session.messages.length > 0;
                
                html += `
                    <div class="session">
                        <h3>Session ${index + 1}: ${session.session_id}</h3>
                        <div class="context-info">
                            <strong>Business Idea:</strong> 
                            <span class="${hasBusinessIdea ? 'filled-field' : 'empty-field'}">
                                ${hasBusinessIdea ? session.business_idea : 'EMPTY'}
                            </span>
                        </div>
                        <div class="context-info">
                            <strong>Target Customer:</strong> 
                            <span class="${hasTargetCustomer ? 'filled-field' : 'empty-field'}">
                                ${hasTargetCustomer ? session.target_customer : 'EMPTY'}
                            </span>
                        </div>
                        <div class="context-info">
                            <strong>Problem:</strong> 
                            <span class="${hasProblem ? 'filled-field' : 'empty-field'}">
                                ${hasProblem ? session.problem : 'EMPTY'}
                            </span>
                        </div>
                        <div class="context-info">
                            <strong>Messages:</strong> ${hasMessages ? session.messages.length : 0}
                            <strong>Questions Generated:</strong> ${session.questions_generated ? 'Yes' : 'No'}
                        </div>
                        <button onclick="cleanupSpecificSession('${session.session_id}')">
                            Cleanup This Session
                        </button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function runCleanup() {
            log('Running standard cleanup...');
            
            // Simulate the cleanupCorruptedSessions method
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.sessions);
                if (!stored) {
                    log('No sessions to cleanup');
                    return;
                }

                const sessions = JSON.parse(stored);
                const sessionsArray = Array.isArray(sessions) ? sessions : Object.values(sessions);
                
                let cleanedSessions = [];
                let removedCount = 0;
                let fixedCount = 0;

                for (const session of sessionsArray) {
                    const hasMessages = Array.isArray(session.messages) && session.messages.length > 0;
                    const isCorrupted = session.questions_generated && !hasMessages;

                    if (isCorrupted) {
                        log(`Removing corrupted session ${session.session_id}`, 'warning');
                        removedCount++;
                        continue;
                    }

                    if (hasMessages) {
                        const cleanedSession = fixMixedContentInSession(session);
                        if (cleanedSession !== session) {
                            fixedCount++;
                            log(`Fixed mixed content in session ${session.session_id}`, 'success');
                        }
                        cleanedSessions.push(cleanedSession);
                    } else {
                        cleanedSessions.push(session);
                    }
                }

                if (removedCount > 0 || fixedCount > 0) {
                    localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(cleanedSessions));
                    log(`Cleanup complete: removed ${removedCount} corrupted sessions, fixed ${fixedCount} sessions`, 'success');
                } else {
                    log('No cleanup needed - all sessions are clean');
                }

                showCurrentSessions();
            } catch (error) {
                log(`Cleanup failed: ${error.message}`, 'error');
            }
        }

        function forceCleanupAll() {
            log('Running force cleanup on all sessions...');
            
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.sessions);
                if (!stored) {
                    log('No sessions to cleanup');
                    return;
                }

                const sessions = JSON.parse(stored);
                const sessionsArray = Array.isArray(sessions) ? sessions : Object.values(sessions);

                log(`Processing ${sessionsArray.length} sessions with improved extraction logic`);

                let processedCount = 0;
                const cleanedSessions = sessionsArray.map((session) => {
                    if (Array.isArray(session.messages) && session.messages.length > 0) {
                        log(`Force processing session ${session.session_id}: "${session.business_idea}"`);
                        const cleanedSession = fixMixedContentInSession(session);
                        if (cleanedSession !== session) {
                            processedCount++;
                        }
                        return cleanedSession;
                    }
                    return session;
                });

                if (processedCount > 0) {
                    localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(cleanedSessions));
                    log(`Force cleanup complete: processed ${processedCount} sessions`, 'success');
                } else {
                    log('Force cleanup complete: no changes needed');
                }

                showCurrentSessions();
            } catch (error) {
                log(`Force cleanup failed: ${error.message}`, 'error');
            }
        }

        function cleanupSpecificSession(sessionId) {
            log(`Cleaning up specific session: ${sessionId}`);
            
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.sessions);
                if (!stored) {
                    log('No sessions found');
                    return;
                }

                const sessions = JSON.parse(stored);
                const sessionsArray = Array.isArray(sessions) ? sessions : Object.values(sessions);

                const sessionIndex = sessionsArray.findIndex(s => s.session_id === sessionId);
                if (sessionIndex === -1) {
                    log(`Session ${sessionId} not found`, 'error');
                    return;
                }

                const session = sessionsArray[sessionIndex];
                log(`Current context: target_customer="${session.target_customer}", problem="${session.problem}"`);
                
                const cleanedSession = fixMixedContentInSession(session);

                if (cleanedSession !== session) {
                    sessionsArray[sessionIndex] = cleanedSession;
                    localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(sessionsArray));
                    log(`Fixed mixed content in session ${sessionId}`, 'success');
                } else {
                    log(`Session ${sessionId} was already clean`);
                }

                showCurrentSessions();
            } catch (error) {
                log(`Error cleaning session ${sessionId}: ${error.message}`, 'error');
            }
        }

        // Simplified version of the extraction logic for testing
        function extractContextFromCleanedMessages(messages) {
            log(`Analyzing ${messages.length} messages for business context`);
            
            let target_customer = '';
            let problem = '';

            // Strategy 1: Look for assistant-user question-answer pairs
            for (let i = 0; i < messages.length - 1; i++) {
                const currentMsg = messages[i];
                const nextMsg = messages[i + 1];

                if (currentMsg.role === 'assistant' && nextMsg.role === 'user') {
                    const assistantContent = currentMsg.content.toLowerCase();
                    const userResponse = nextMsg.content.trim();

                    // Expanded patterns for target customer questions
                    const targetCustomerPatterns = [
                        'target customer', 'who specifically', 'who would be your', 'who are you targeting',
                        'who is your audience', 'who would use', 'who would benefit', 'who are your customers',
                        'what type of customers', 'which customers', 'customer segment', 'target market',
                        'who would pay', 'who needs this', 'primary users', 'ideal customer'
                    ];

                    const isTargetCustomerQuestion = targetCustomerPatterns.some(pattern => 
                        assistantContent.includes(pattern)
                    );

                    if (isTargetCustomerQuestion && userResponse.length > 10) {
                        target_customer = userResponse;
                        log(`Extracted target_customer from Q&A: "${target_customer}"`, 'success');
                    }

                    // Expanded patterns for problem/pain point questions
                    const problemPatterns = [
                        'pain point', 'problem', 'what\'s the main', 'challenge', 'difficulty',
                        'issue', 'struggle', 'frustration', 'what bothers', 'what\'s wrong',
                        'what needs fixing', 'what\'s broken', 'inefficiency', 'bottleneck',
                        'what\'s missing', 'gap in the market', 'unmet need'
                    ];

                    const isProblemQuestion = problemPatterns.some(pattern => 
                        assistantContent.includes(pattern)
                    );

                    if (isProblemQuestion && userResponse.length > 10) {
                        problem = userResponse;
                        log(`Extracted problem from Q&A: "${problem}"`, 'success');
                    }
                }
            }

            // Strategy 2: Look for business context in all user messages
            if (!target_customer || !problem) {
                log('Using fallback extraction from all user messages');
                
                for (const msg of messages) {
                    if (msg.role === 'user') {
                        const originalContent = msg.content.trim();

                        // Look for target customer patterns
                        if (!target_customer) {
                            const customerSentencePatterns = [
                                /(.{0,50})(smes?|small businesses?|enterprises?|companies|agencies|startups|retailers|restaurants|clinics|hospitals|schools|universities|developers|designers|consultants|freelancers|professionals)(.{0,100})/i,
                                /(target|serve|help|work with|focus on)(.{0,100})/i
                            ];

                            for (const pattern of customerSentencePatterns) {
                                const match = originalContent.match(pattern);
                                if (match && match[0].length > 20) {
                                    target_customer = match[0].trim();
                                    log(`Extracted target_customer from context: "${target_customer}"`, 'success');
                                    break;
                                }
                            }
                        }

                        // Look for problem patterns
                        if (!problem) {
                            const problemSentencePatterns = [
                                /(.{0,100})(outdated|manual|inefficient|slow|expensive|difficult|time-consuming|error-prone|unreliable|lacking|missing|broken|frustrating|complicated|confusing)(.{0,100})/i,
                                /(problem|issue|challenge|difficulty|struggle|pain|frustration)(.{0,100})/i
                            ];

                            for (const pattern of problemSentencePatterns) {
                                const match = originalContent.match(pattern);
                                if (match && match[0].length > 15) {
                                    problem = match[0].trim();
                                    log(`Extracted problem from context: "${problem}"`, 'success');
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            log(`Final extraction results: target_customer="${target_customer}", problem="${problem}"`);
            return { target_customer, problem };
        }

        function fixMixedContentInSession(session) {
            if (!Array.isArray(session.messages) || session.messages.length === 0) {
                return session;
            }

            // Check for mixed business contexts
            const businessIntroMessages = session.messages.filter(msg =>
                msg.role === 'user' && (
                    msg.content.toLowerCase().includes('i want to open') ||
                    msg.content.toLowerCase().includes('i want to create') ||
                    msg.content.toLowerCase().includes('i want to start')
                )
            );

            if (businessIntroMessages.length > 1) {
                log(`Mixed content detected: Found ${businessIntroMessages.length} different business conversations`, 'warning');

                const sortedBusinessMessages = businessIntroMessages.sort((a, b) =>
                    new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
                );
                const latestBusinessMessage = sortedBusinessMessages[0];
                const latestBusinessTimestamp = new Date(latestBusinessMessage.timestamp);

                log(`Keeping only the latest business conversation: "${latestBusinessMessage.content}"`);

                const cleanedMessages = session.messages.filter(msg => {
                    const msgTimestamp = new Date(msg.timestamp);
                    return msgTimestamp >= latestBusinessTimestamp;
                });

                const latestBusinessIdea = extractBusinessIdeaFromMessage(latestBusinessMessage.content);
                const extractedContext = extractContextFromCleanedMessages(cleanedMessages);

                const messagesWithoutQuestionnaire = cleanedMessages.filter(msg =>
                    msg.content !== 'COMPREHENSIVE_QUESTIONS_COMPONENT'
                );

                const finalTargetCustomer = extractedContext.target_customer || session.target_customer || '';
                const finalProblem = extractedContext.problem || session.problem || '';
                
                log(`Final session context: target_customer="${finalTargetCustomer}", problem="${finalProblem}"`);

                return {
                    ...session,
                    messages: messagesWithoutQuestionnaire,
                    message_count: messagesWithoutQuestionnaire.length,
                    business_idea: latestBusinessIdea,
                    target_customer: finalTargetCustomer,
                    problem: finalProblem,
                    questions_generated: false
                };
            }

            return session;
        }

        function extractBusinessIdeaFromMessage(content) {
            const patterns = [
                /i want to open (.+)/i,
                /i want to create (.+)/i,
                /i want to start (.+)/i
            ];

            for (const pattern of patterns) {
                const match = content.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }

            return content;
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            log('Research Context Extraction Test initialized');
            showCurrentSessions();
        });
    </script>
</body>
</html>
