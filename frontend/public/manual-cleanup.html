<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual Research Cleanup</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .success { background: #28a745; }
        .warning { background: #ffc107; color: black; }
        .danger { background: #dc3545; }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
            font-size: 12px;
        }
        .session-card {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            background: #f9f9f9;
        }
        .empty { color: #dc3545; font-weight: bold; }
        .filled { color: #28a745; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Manual Research Context Cleanup</h1>
        <p>This tool manually triggers the improved context extraction cleanup on research sessions.</p>
        
        <div>
            <button onclick="showCurrentState()" class="success">Show Current Sessions</button>
            <button onclick="runImprovedCleanup()" class="warning">Run Improved Cleanup</button>
            <button onclick="testSpecificSession()" class="warning">Test Vibe Coding Session</button>
            <button onclick="clearLog()">Clear Log</button>
        </div>
        
        <div>
            <button onclick="openResearchPage()" class="success">Open Research Simulation Page</button>
            <button onclick="refreshPage()" class="warning">Refresh This Page</button>
        </div>
    </div>

    <div class="container">
        <h2>Sessions Status</h2>
        <div id="sessions-status"></div>
    </div>

    <div class="container">
        <h2>Console Log</h2>
        <div id="log" class="log"></div>
    </div>

    <script>
        const STORAGE_KEYS = {
            sessions: 'axwise_research_sessions',
            currentSession: 'axwise_current_research_session',
            userId: 'axwise_anonymous_user_id'
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`${prefix} ${message}`);
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        function getSessions() {
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.sessions);
                if (!stored) return [];
                
                const sessions = JSON.parse(stored);
                return Array.isArray(sessions) ? sessions : Object.values(sessions);
            } catch (error) {
                log(`Error reading sessions: ${error.message}`, 'error');
                return [];
            }
        }

        function showCurrentState() {
            const sessions = getSessions();
            const container = document.getElementById('sessions-status');
            
            if (sessions.length === 0) {
                container.innerHTML = '<p>No sessions found in localStorage.</p>';
                log('No sessions found');
                return;
            }

            log(`Found ${sessions.length} sessions`);
            
            let html = '';
            let vibeSessionFound = false;
            
            sessions.forEach((session, index) => {
                const hasBusinessIdea = session.business_idea && session.business_idea.trim();
                const hasTargetCustomer = session.target_customer && session.target_customer.trim();
                const hasProblem = session.problem && session.problem.trim();
                const hasMessages = session.messages && session.messages.length > 0;
                
                const isVibeSession = session.business_idea && session.business_idea.toLowerCase().includes('vibe');
                if (isVibeSession) vibeSessionFound = true;
                
                html += `
                    <div class="session-card" ${isVibeSession ? 'style="border: 2px solid #007bff; background: #e7f3ff;"' : ''}>
                        <h3>Session ${index + 1}: ${session.session_id} ${isVibeSession ? 'üéØ (VIBE SESSION)' : ''}</h3>
                        <p><strong>Business Idea:</strong> 
                            <span class="${hasBusinessIdea ? 'filled' : 'empty'}">
                                ${hasBusinessIdea ? session.business_idea : 'EMPTY'}
                            </span>
                        </p>
                        <p><strong>Target Customer:</strong> 
                            <span class="${hasTargetCustomer ? 'filled' : 'empty'}">
                                ${hasTargetCustomer ? session.target_customer : 'EMPTY'}
                            </span>
                        </p>
                        <p><strong>Problem:</strong> 
                            <span class="${hasProblem ? 'filled' : 'empty'}">
                                ${hasProblem ? session.problem : 'EMPTY'}
                            </span>
                        </p>
                        <p><strong>Messages:</strong> ${hasMessages ? session.messages.length : 0} | 
                           <strong>Questions Generated:</strong> ${session.questions_generated ? 'Yes' : 'No'}</p>
                        <button onclick="debugSpecificSession('${session.session_id}')" class="warning">Debug This Session</button>
                    </div>
                `;
            });
            
            if (vibeSessionFound) {
                log('‚úÖ Found Vibe Coding Agency session!', 'success');
            } else {
                log('‚ö†Ô∏è No Vibe Coding Agency session found', 'warning');
            }
            
            container.innerHTML = html;
        }

        function extractContextFromCleanedMessages(messages) {
            log(`üîç CONTEXT EXTRACTION: Analyzing ${messages.length} messages for business context`);
            
            let target_customer = '';
            let problem = '';

            // Strategy 1: Look for assistant-user question-answer pairs with expanded patterns
            for (let i = 0; i < messages.length - 1; i++) {
                const currentMsg = messages[i];
                const nextMsg = messages[i + 1];

                if (currentMsg.role === 'assistant' && nextMsg.role === 'user') {
                    const assistantContent = currentMsg.content.toLowerCase();
                    const userResponse = nextMsg.content.trim();

                    log(`üîç Checking assistant question: "${assistantContent.substring(0, 100)}..."`);
                    log(`üîç User response: "${userResponse.substring(0, 100)}..."`);

                    // Expanded patterns for target customer questions
                    const targetCustomerPatterns = [
                        'target customer', 'who specifically', 'who would be your', 'who are you targeting',
                        'who is your audience', 'who would use', 'who would benefit', 'who are your customers',
                        'what type of customers', 'which customers', 'customer segment', 'target market',
                        'who would pay', 'who needs this', 'primary users', 'ideal customer'
                    ];

                    const isTargetCustomerQuestion = targetCustomerPatterns.some(pattern => 
                        assistantContent.includes(pattern)
                    );

                    if (isTargetCustomerQuestion && userResponse.length > 10) {
                        target_customer = userResponse;
                        log(`‚úÖ EXTRACTED target_customer from Q&A: "${target_customer}"`, 'success');
                    }

                    // Expanded patterns for problem/pain point questions
                    const problemPatterns = [
                        'pain point', 'problem', 'what\'s the main', 'challenge', 'difficulty',
                        'issue', 'struggle', 'frustration', 'what bothers', 'what\'s wrong',
                        'what needs fixing', 'what\'s broken', 'inefficiency', 'bottleneck',
                        'what\'s missing', 'gap in the market', 'unmet need'
                    ];

                    const isProblemQuestion = problemPatterns.some(pattern => 
                        assistantContent.includes(pattern)
                    );

                    if (isProblemQuestion && userResponse.length > 10) {
                        problem = userResponse;
                        log(`‚úÖ EXTRACTED problem from Q&A: "${problem}"`, 'success');
                    }
                }
            }

            // Strategy 2: Look for business context keywords in all user messages
            if (!target_customer || !problem) {
                log(`üîç FALLBACK EXTRACTION: Looking for business context in all user messages`);
                
                for (const msg of messages) {
                    if (msg.role === 'user') {
                        const content = msg.content.toLowerCase();
                        const originalContent = msg.content.trim();

                        // Look for target customer indicators in user messages
                        if (!target_customer) {
                            // Look for sentences that describe target customers
                            const customerSentencePatterns = [
                                /(.{0,50})(smes?|small businesses?|enterprises?|companies|agencies|startups|retailers|restaurants|clinics|hospitals|schools|universities|developers|designers|consultants|freelancers|professionals)(.{0,100})/i,
                                /(target|serve|help|work with|focus on)(.{0,100})/i
                            ];

                            for (const pattern of customerSentencePatterns) {
                                const match = originalContent.match(pattern);
                                if (match && match[0].length > 20) {
                                    target_customer = match[0].trim();
                                    log(`‚úÖ EXTRACTED target_customer from context: "${target_customer}"`, 'success');
                                    break;
                                }
                            }
                        }

                        // Look for problem indicators in user messages
                        if (!problem) {
                            const problemIndicators = [
                                'outdated', 'manual', 'inefficient', 'slow', 'expensive', 'difficult',
                                'time-consuming', 'error-prone', 'unreliable', 'lacking', 'missing',
                                'broken', 'frustrating', 'complicated', 'confusing'
                            ];

                            const hasProblemContext = problemIndicators.some(indicator => 
                                content.includes(indicator)
                            );

                            if (hasProblemContext && originalContent.length > 20) {
                                // Extract sentences that describe problems
                                const problemSentencePatterns = [
                                    /(.{0,100})(outdated|manual|inefficient|slow|expensive|difficult|time-consuming|error-prone|unreliable|lacking|missing|broken|frustrating|complicated|confusing)(.{0,100})/i,
                                    /(problem|issue|challenge|difficulty|struggle|pain|frustration)(.{0,100})/i
                                ];

                                for (const pattern of problemSentencePatterns) {
                                    const match = originalContent.match(pattern);
                                    if (match && match[0].length > 15) {
                                        problem = match[0].trim();
                                        log(`‚úÖ EXTRACTED problem from context: "${problem}"`, 'success');
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            log(`üîç FINAL EXTRACTION RESULTS:`);
            log(`   target_customer: "${target_customer}"`);
            log(`   problem: "${problem}"`);

            return { target_customer, problem };
        }

        function runImprovedCleanup() {
            log('üîß Running improved cleanup on all sessions...');
            
            const sessions = getSessions();
            if (sessions.length === 0) {
                log('No sessions to cleanup', 'warning');
                return;
            }

            let processedCount = 0;
            const updatedSessions = sessions.map(session => {
                if (Array.isArray(session.messages) && session.messages.length > 0) {
                    log(`üîß Processing session ${session.session_id}: "${session.business_idea}"`);
                    log(`   Current: target_customer="${session.target_customer}", problem="${session.problem}"`);
                    
                    const extracted = extractContextFromCleanedMessages(session.messages);
                    
                    const updatedSession = {
                        ...session,
                        target_customer: extracted.target_customer || session.target_customer || '',
                        problem: extracted.problem || session.problem || '',
                        updated_at: new Date().toISOString()
                    };
                    
                    if (extracted.target_customer || extracted.problem) {
                        processedCount++;
                        log(`‚úÖ Updated session ${session.session_id}`, 'success');
                        log(`   New: target_customer="${updatedSession.target_customer}", problem="${updatedSession.problem}"`);
                    }
                    
                    return updatedSession;
                }
                return session;
            });

            if (processedCount > 0) {
                localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(updatedSessions));
                log(`üîß Cleanup complete: processed ${processedCount} sessions`, 'success');
            } else {
                log('üîß No sessions needed updates', 'warning');
            }

            // Refresh the display
            showCurrentState();
        }

        function testSpecificSession() {
            const sessions = getSessions();
            const vibeSession = sessions.find(s => 
                s.business_idea && s.business_idea.toLowerCase().includes('vibe')
            );
            
            if (!vibeSession) {
                log('No Vibe Coding Agency session found', 'error');
                return;
            }
            
            log(`üéØ Testing Vibe Coding Agency session: ${vibeSession.session_id}`);
            debugSpecificSession(vibeSession.session_id);
        }

        function debugSpecificSession(sessionId) {
            const sessions = getSessions();
            const session = sessions.find(s => s.session_id === sessionId);
            
            if (!session) {
                log(`Session ${sessionId} not found`, 'error');
                return;
            }

            log(`üîç Debugging session: ${sessionId}`);
            log(`   Business Idea: "${session.business_idea}"`);
            log(`   Current Target Customer: "${session.target_customer}"`);
            log(`   Current Problem: "${session.problem}"`);
            log(`   Messages: ${session.messages ? session.messages.length : 0}`);
            
            if (session.messages && session.messages.length > 0) {
                log(`üìù Messages in session:`);
                session.messages.forEach((msg, i) => {
                    log(`   ${i + 1}. [${msg.role}] ${msg.content.substring(0, 150)}${msg.content.length > 150 ? '...' : ''}`);
                });
                
                log(`üß™ Testing extraction...`);
                const extracted = extractContextFromCleanedMessages(session.messages);
                
                if (extracted.target_customer || extracted.problem) {
                    log(`üîß Applying extracted context to session...`);
                    
                    const sessionIndex = sessions.findIndex(s => s.session_id === sessionId);
                    if (sessionIndex >= 0) {
                        sessions[sessionIndex] = {
                            ...sessions[sessionIndex],
                            target_customer: extracted.target_customer || sessions[sessionIndex].target_customer || '',
                            problem: extracted.problem || sessions[sessionIndex].problem || '',
                            updated_at: new Date().toISOString()
                        };
                        
                        localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(sessions));
                        log(`‚úÖ Session updated successfully!`, 'success');
                        showCurrentState();
                    }
                } else {
                    log(`‚ö†Ô∏è No context could be extracted from this session`, 'warning');
                }
            } else {
                log(`‚ö†Ô∏è Session has no messages to analyze`, 'warning');
            }
        }

        function openResearchPage() {
            window.open('/unified-dashboard/research', '_blank');
        }

        function refreshPage() {
            window.location.reload();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('Manual cleanup tool loaded');
            showCurrentState();
        });
    </script>
</body>
</html>
