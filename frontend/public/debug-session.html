<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Research Session</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        .session-info {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            background: #f9f9f9;
        }
        .message {
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            margin: 5px 0;
            background: #fff;
        }
        .user-message {
            border-left: 4px solid #007bff;
        }
        .assistant-message {
            border-left: 4px solid #28a745;
        }
        .empty-field {
            color: #dc3545;
            font-weight: bold;
        }
        .filled-field {
            color: #28a745;
        }
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Debug Research Session Context Extraction</h1>
        <p>This tool helps debug why context extraction isn't working for specific sessions.</p>
        
        <div>
            <select id="sessionSelect">
                <option value="">Select a session to debug...</option>
            </select>
            <button onclick="loadSessionData()">Load Session Data</button>
            <button onclick="testExtraction()">Test Extraction on Selected Session</button>
            <button onclick="forceCleanupSelected()">Force Cleanup Selected Session</button>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <div class="container">
        <h2>Session Information</h2>
        <div id="session-info"></div>
    </div>

    <div class="container">
        <h2>Conversation Messages</h2>
        <div id="messages-container"></div>
    </div>

    <div class="container">
        <h2>Debug Log</h2>
        <div id="log" class="log"></div>
    </div>

    <script>
        const STORAGE_KEYS = {
            sessions: 'axwise_research_sessions',
            currentSession: 'axwise_current_research_session',
            userId: 'axwise_anonymous_user_id'
        };

        let currentSession = null;

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`${prefix} ${message}`);
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        function getSessions() {
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.sessions);
                if (!stored) return [];
                
                const sessions = JSON.parse(stored);
                return Array.isArray(sessions) ? sessions : Object.values(sessions);
            } catch (error) {
                log(`Error reading sessions: ${error.message}`, 'error');
                return [];
            }
        }

        function populateSessionSelect() {
            const sessions = getSessions();
            const select = document.getElementById('sessionSelect');
            
            select.innerHTML = '<option value="">Select a session to debug...</option>';
            
            sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = session.session_id;
                option.textContent = `${index + 1}. ${session.business_idea || 'Untitled'} (${session.session_id})`;
                select.appendChild(option);
            });
            
            log(`Found ${sessions.length} sessions`);
        }

        function loadSessionData() {
            const sessionId = document.getElementById('sessionSelect').value;
            if (!sessionId) {
                log('Please select a session first', 'warning');
                return;
            }

            const sessions = getSessions();
            currentSession = sessions.find(s => s.session_id === sessionId);
            
            if (!currentSession) {
                log(`Session ${sessionId} not found`, 'error');
                return;
            }

            log(`Loading session data for: ${sessionId}`);
            displaySessionInfo(currentSession);
            displayMessages(currentSession.messages || []);
        }

        function displaySessionInfo(session) {
            const container = document.getElementById('session-info');
            
            const hasBusinessIdea = session.business_idea && session.business_idea.trim();
            const hasTargetCustomer = session.target_customer && session.target_customer.trim();
            const hasProblem = session.problem && session.problem.trim();
            const hasMessages = session.messages && session.messages.length > 0;
            
            container.innerHTML = `
                <div class="session-info">
                    <h3>Session: ${session.session_id}</h3>
                    <p><strong>Business Idea:</strong> 
                        <span class="${hasBusinessIdea ? 'filled-field' : 'empty-field'}">
                            ${hasBusinessIdea ? session.business_idea : 'EMPTY'}
                        </span>
                    </p>
                    <p><strong>Target Customer:</strong> 
                        <span class="${hasTargetCustomer ? 'filled-field' : 'empty-field'}">
                            ${hasTargetCustomer ? session.target_customer : 'EMPTY'}
                        </span>
                    </p>
                    <p><strong>Problem:</strong> 
                        <span class="${hasProblem ? 'filled-field' : 'empty-field'}">
                            ${hasProblem ? session.problem : 'EMPTY'}
                        </span>
                    </p>
                    <p><strong>Messages:</strong> ${hasMessages ? session.messages.length : 0}</p>
                    <p><strong>Questions Generated:</strong> ${session.questions_generated ? 'Yes' : 'No'}</p>
                    <p><strong>Created:</strong> ${session.created_at}</p>
                    <p><strong>Updated:</strong> ${session.updated_at}</p>
                </div>
            `;
        }

        function displayMessages(messages) {
            const container = document.getElementById('messages-container');
            
            if (!messages || messages.length === 0) {
                container.innerHTML = '<p>No messages found in this session.</p>';
                return;
            }

            let html = `<p>Found ${messages.length} messages:</p>`;
            
            messages.forEach((msg, index) => {
                const messageClass = msg.role === 'user' ? 'user-message' : 'assistant-message';
                html += `
                    <div class="message ${messageClass}">
                        <strong>${index + 1}. [${msg.role.toUpperCase()}]</strong>
                        <p>${msg.content}</p>
                        <small>Timestamp: ${msg.timestamp}</small>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function extractContextFromCleanedMessages(messages) {
            log(`üîç CONTEXT EXTRACTION: Analyzing ${messages.length} messages for business context`);
            
            let target_customer = '';
            let problem = '';

            // Strategy 1: Look for assistant-user question-answer pairs with expanded patterns
            for (let i = 0; i < messages.length - 1; i++) {
                const currentMsg = messages[i];
                const nextMsg = messages[i + 1];

                if (currentMsg.role === 'assistant' && nextMsg.role === 'user') {
                    const assistantContent = currentMsg.content.toLowerCase();
                    const userResponse = nextMsg.content.trim();

                    log(`üîç Checking Q&A pair ${i + 1}:`);
                    log(`   Assistant: "${assistantContent.substring(0, 150)}..."`);
                    log(`   User: "${userResponse.substring(0, 150)}..."`);

                    // Expanded patterns for target customer questions
                    const targetCustomerPatterns = [
                        'target customer', 'who specifically', 'who would be your', 'who are you targeting',
                        'who is your audience', 'who would use', 'who would benefit', 'who are your customers',
                        'what type of customers', 'which customers', 'customer segment', 'target market',
                        'who would pay', 'who needs this', 'primary users', 'ideal customer'
                    ];

                    const matchedTargetPattern = targetCustomerPatterns.find(pattern => 
                        assistantContent.includes(pattern)
                    );

                    if (matchedTargetPattern && userResponse.length > 10) {
                        target_customer = userResponse;
                        log(`‚úÖ EXTRACTED target_customer from Q&A (pattern: "${matchedTargetPattern}"): "${target_customer}"`, 'success');
                    }

                    // Expanded patterns for problem/pain point questions
                    const problemPatterns = [
                        'pain point', 'problem', 'what\'s the main', 'challenge', 'difficulty',
                        'issue', 'struggle', 'frustration', 'what bothers', 'what\'s wrong',
                        'what needs fixing', 'what\'s broken', 'inefficiency', 'bottleneck',
                        'what\'s missing', 'gap in the market', 'unmet need'
                    ];

                    const matchedProblemPattern = problemPatterns.find(pattern => 
                        assistantContent.includes(pattern)
                    );

                    if (matchedProblemPattern && userResponse.length > 10) {
                        problem = userResponse;
                        log(`‚úÖ EXTRACTED problem from Q&A (pattern: "${matchedProblemPattern}"): "${problem}"`, 'success');
                    }
                }
            }

            // Strategy 2: Look for business context keywords in all user messages
            if (!target_customer || !problem) {
                log(`üîç FALLBACK EXTRACTION: Looking for business context in all user messages`);
                
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    if (msg.role === 'user') {
                        const content = msg.content.toLowerCase();
                        const originalContent = msg.content.trim();

                        log(`üîç Analyzing user message ${i + 1}: "${originalContent.substring(0, 100)}..."`);

                        // Look for target customer indicators in user messages
                        if (!target_customer) {
                            // Look for sentences that describe target customers
                            const customerSentencePatterns = [
                                /(.{0,50})(smes?|small businesses?|enterprises?|companies|agencies|startups|retailers|restaurants|clinics|hospitals|schools|universities|developers|designers|consultants|freelancers|professionals)(.{0,100})/i,
                                /(target|serve|help|work with|focus on)(.{0,100})/i
                            ];

                            for (const pattern of customerSentencePatterns) {
                                const match = originalContent.match(pattern);
                                if (match && match[0].length > 20) {
                                    target_customer = match[0].trim();
                                    log(`‚úÖ EXTRACTED target_customer from context (pattern match): "${target_customer}"`, 'success');
                                    break;
                                }
                            }
                        }

                        // Look for problem indicators in user messages
                        if (!problem) {
                            const problemIndicators = [
                                'outdated', 'manual', 'inefficient', 'slow', 'expensive', 'difficult',
                                'time-consuming', 'error-prone', 'unreliable', 'lacking', 'missing',
                                'broken', 'frustrating', 'complicated', 'confusing'
                            ];

                            const foundProblemIndicator = problemIndicators.find(indicator => 
                                content.includes(indicator)
                            );

                            if (foundProblemIndicator && originalContent.length > 20) {
                                log(`üîç Found problem indicator "${foundProblemIndicator}" in message`);
                                
                                // Extract sentences that describe problems
                                const problemSentencePatterns = [
                                    /(.{0,100})(outdated|manual|inefficient|slow|expensive|difficult|time-consuming|error-prone|unreliable|lacking|missing|broken|frustrating|complicated|confusing)(.{0,100})/i,
                                    /(problem|issue|challenge|difficulty|struggle|pain|frustration)(.{0,100})/i
                                ];

                                for (const pattern of problemSentencePatterns) {
                                    const match = originalContent.match(pattern);
                                    if (match && match[0].length > 15) {
                                        problem = match[0].trim();
                                        log(`‚úÖ EXTRACTED problem from context (pattern match): "${problem}"`, 'success');
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            log(`üîç FINAL EXTRACTION RESULTS:`);
            log(`   target_customer: "${target_customer}"`);
            log(`   problem: "${problem}"`);

            return { target_customer, problem };
        }

        function testExtraction() {
            if (!currentSession) {
                log('Please load a session first', 'warning');
                return;
            }

            if (!currentSession.messages || currentSession.messages.length === 0) {
                log('No messages found in current session', 'warning');
                return;
            }

            log(`üß™ Testing extraction on session: ${currentSession.session_id}`);
            log(`Current values: target_customer="${currentSession.target_customer}", problem="${currentSession.problem}"`);
            
            const extracted = extractContextFromCleanedMessages(currentSession.messages);
            
            log(`\nüìä EXTRACTION RESULTS:`);
            log(`   Extracted target_customer: "${extracted.target_customer}"`);
            log(`   Extracted problem: "${extracted.problem}"`);
            log(`   Would improve target_customer: ${extracted.target_customer && !currentSession.target_customer ? 'YES' : 'NO'}`);
            log(`   Would improve problem: ${extracted.problem && !currentSession.problem ? 'YES' : 'NO'}`);
        }

        function forceCleanupSelected() {
            if (!currentSession) {
                log('Please load a session first', 'warning');
                return;
            }

            log(`üîß Force cleaning up session: ${currentSession.session_id}`);
            
            // Simulate the cleanup process
            const extracted = extractContextFromCleanedMessages(currentSession.messages);
            
            // Update the session
            const sessions = getSessions();
            const sessionIndex = sessions.findIndex(s => s.session_id === currentSession.session_id);
            
            if (sessionIndex >= 0) {
                const updatedSession = {
                    ...sessions[sessionIndex],
                    target_customer: extracted.target_customer || sessions[sessionIndex].target_customer || '',
                    problem: extracted.problem || sessions[sessionIndex].problem || '',
                    updated_at: new Date().toISOString()
                };
                
                sessions[sessionIndex] = updatedSession;
                localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(sessions));
                
                log(`‚úÖ Updated session with extracted context`, 'success');
                log(`   New target_customer: "${updatedSession.target_customer}"`);
                log(`   New problem: "${updatedSession.problem}"`);
                
                // Reload the session data
                currentSession = updatedSession;
                displaySessionInfo(currentSession);
            } else {
                log('Session not found in localStorage', 'error');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('Debug session tool loaded');
            populateSessionSelect();
        });
    </script>
</body>
</html>
